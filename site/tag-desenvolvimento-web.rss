<?xml version="1.0" encoding="utf-8"?><rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Diário de um Dev JR</title><link>https://lg8609a.github.io</link><description>Publicações semanais sobre assuntos que estudo, curiosidades, dificuldades e dúvidas sobre diferentes stacks e sobre as minhas experiências pessoais que rodeiam um dev júnior</description><pubDate>Fri, 01 Aug 2025 00:00:00 GMT</pubDate><lastBuildDate>Fri, 01 Aug 2025 12:42:05 GMT</lastBuildDate><generator>marmite</generator><item><title>SQL vs. NoSQL: Compreendendo as Diferenças e Quando Utilizar</title><link>https://lg8609a.github.io/sql-vs-nosql-compreendendo-as-diferenc-as-e-quando-utilizar.html</link><description><![CDATA["A escolha de um banco de dados é uma das decisões arquiteturais mais críticas no desenvolvimento de uma aplicação. Este post apresenta uma análise comparativa entre os paradigmas SQL e NoSQL."]]></description><category>Desenvolvimento Web</category><category>Arquitetura de Software</category><category>Banco de Dados</category><category>SQL</category><category>NoSQL</category><category>Boas Práticas</category><guid>https://lg8609a.github.io/sql-vs-nosql-compreendendo-as-diferenc-as-e-quando-utilizar.html</guid><pubDate>Fri, 01 Aug 2025 00:00:00 GMT</pubDate><source url="https://lg8609a.github.io">tag-desenvolvimento-web</source><content:encoded><![CDATA[<h1><a href="#sql-vs-nosql-compreendendo-as-diferenças-e-casos-de-uso" aria-hidden="true" class="anchor" id="sql-vs-nosql-compreendendo-as-diferenças-e-casos-de-uso"></a>SQL vs. NoSQL: Compreendendo as Diferenças e Casos de Uso</h1>
<p>A escolha de um banco de dados é uma das decisões arquiteturais mais críticas no desenvolvimento de uma aplicação. Ela impacta diretamente a performance, a escalabilidade, a consistência dos dados e a complexidade do desenvolvimento. As duas principais categorias de sistemas de gerenciamento de bancos de dados (SGBDs) são SQL (relacionais) e NoSQL (não relacionais).</p>
<p>Não se trata de uma competição para determinar qual é a &quot;melhor&quot; tecnologia, mas sim de identificar a ferramenta mais adequada para um problema específico. Esse é o primeiro passo para projetar sistemas eficientes e robustos.</p>
<p>Este post apresenta uma análise comparativa entre os paradigmas SQL e NoSQL, detalhando suas características, principais diferenças e cenários de aplicação ideais.</p>
<h2><a href="#bancos-de-dados-sql-relacionais-estrutura-e-consistência" aria-hidden="true" class="anchor" id="bancos-de-dados-sql-relacionais-estrutura-e-consistência"></a>Bancos de Dados SQL (Relacionais): Estrutura e Consistência</h2>
<p>Os bancos de dados relacionais, que utilizam a Structured Query Language (SQL) como padrão de consulta, organizam os dados em tabelas (ou relações) compostas por linhas e colunas. Este modelo é fundamentado na teoria matemática das relações e tem sido o padrão da indústria por décadas.</p>
<h3><a href="#principais-características" aria-hidden="true" class="anchor" id="principais-características"></a>Principais Características:</h3>
<p><strong>Esquema Rígido (Schema-on-Write):</strong> A estrutura dos dados, incluindo tabelas, colunas e tipos de dados, deve ser definida antes da inserção de qualquer registro. Essa rigidez garante a uniformidade e a previsibilidade dos dados.</p>
<p><strong>Propriedades ACID:</strong> A maioria dos SGBDs relacionais adere às propriedades ACID (Atomicidade, Consistência, Isolamento e Durabilidade). Este conjunto de garantias assegura a integridade das transações, tornando-os ideais para sistemas onde a confiabilidade transacional é crítica (e.g., sistemas financeiros).</p>
<p><strong>Normalização de Dados:</strong> Os dados são geralmente normalizados para reduzir a redundância e melhorar a integridade, distribuindo-os em múltiplas tabelas interligadas por chaves estrangeiras.</p>
<p><strong>Escalabilidade Vertical:</strong> Tradicionalmente, a escalabilidade é alcançada através do scaling up, ou seja, aumentando os recursos de hardware (CPU, RAM, armazenamento) de um único servidor.</p>
<p><strong>Exemplos de SGBDs:</strong> PostgreSQL, MySQL, MariaDB, Microsoft SQL Server, Oracle Database.</p>
<h2><a href="#bancos-de-dados-nosql-não-relacionais-flexibilidade-e-escalabilidade" aria-hidden="true" class="anchor" id="bancos-de-dados-nosql-não-relacionais-flexibilidade-e-escalabilidade"></a>Bancos de Dados NoSQL (Não Relacionais): Flexibilidade e Escalabilidade</h2>
<p>O termo NoSQL (&quot;Not Only SQL&quot;) abrange uma vasta categoria de bancos de dados que não seguem o modelo relacional tradicional. Eles foram projetados para atender às demandas de aplicações web modernas, como grandes volumes de dados (Big Data), baixa latência e alta escalabilidade.</p>
<h3><a href="#principais-características-1" aria-hidden="true" class="anchor" id="principais-características-1"></a>Principais Características:</h3>
<p><strong>Esquema Flexível (Schema-on-Read):</strong> Permitem a inserção de dados sem um esquema predefinido. A estrutura pode variar de um registro para outro dentro da mesma coleção, oferecendo grande flexibilidade para dados semiestruturados ou não estruturados.</p>
<p><strong>Diversidade de Modelos de Dados:</strong> Existem vários tipos de bancos NoSQL, cada um otimizado para um tipo de problema:</p>
<ul>
<li><strong>Documentos:</strong> Armazenam dados em formatos como JSON ou BSON (e.g., MongoDB, CouchDB).</li>
<li><strong>Chave-Valor:</strong> O modelo mais simples, associa uma chave única a um valor (e.g., Redis, Amazon DynamoDB).</li>
<li><strong>Colunares (Wide-Column):</strong> Otimizados para consultas rápidas em grandes conjuntos de dados, armazenando dados em colunas em vez de linhas (e.g., Apache Cassandra, Google Bigtable).</li>
<li><strong>Grafos:</strong> Projetados para armazenar e navegar por relações complexas entre entidades (e.g., Neo4j, Amazon Neptune).</li>
</ul>
<p><strong>Teorema CAP e Consistência Eventual (BASE):</strong> Em sistemas distribuídos, o Teorema CAP afirma que é impossível garantir simultaneamente Consistência, Disponibilidade (Availability) e Tolerância a Partições. Muitos bancos NoSQL priorizam a disponibilidade e a tolerância a partições, adotando um modelo de consistência eventual (modelo BASE: Basically Available, Soft state, Eventual consistency).</p>
<p><strong>Escalabilidade Horizontal:</strong> A escalabilidade é tipicamente alcançada através do scaling out, distribuindo os dados e a carga de trabalho por múltiplos servidores (clusterização ou sharding).</p>
<h2><a href="#tabela-comparativa-sql-vs-nosql" aria-hidden="true" class="anchor" id="tabela-comparativa-sql-vs-nosql"></a>Tabela Comparativa: SQL vs. NoSQL</h2>
<div style="border: 1px solid #ccc; border-radius: 8px; padding: 16px; background: #f9f9f9; margin: 24px 0; overflow-x: auto;">
<table style="width: 100%; border-collapse: collapse; margin: 0;">
<thead>
<tr style="background: #e9ecef;">
<th style="border: 1px solid #dee2e6; padding: 12px; text-align: left; font-weight: bold;">Característica</th>
<th style="border: 1px solid #dee2e6; padding: 12px; text-align: left; font-weight: bold;">Bancos SQL (Relacionais)</th>
<th style="border: 1px solid #dee2e6; padding: 12px; text-align: left; font-weight: bold;">Bancos NoSQL (Não Relacionais)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="border: 1px solid #dee2e6; padding: 12px;">Modelo de Dados</td>
<td style="border: 1px solid #dee2e6; padding: 12px;">Tabelas com linhas e colunas (relacional)</td>
<td style="border: 1px solid #dee2e6; padding: 12px;">Documentos, chave-valor, colunares, grafos</td>
</tr>
<tr style="background: #f8f9fa;">
<td style="border: 1px solid #dee2e6; padding: 12px;">Esquema</td>
<td style="border: 1px solid #dee2e6; padding: 12px;">Rígido e predefinido</td>
<td style="border: 1px solid #dee2e6; padding: 12px;">Dinâmico e flexível</td>
</tr>
<tr>
<td style="border: 1px solid #dee2e6; padding: 12px;">Linguagem</td>
<td style="border: 1px solid #dee2e6; padding: 12px;">SQL (Structured Query Language)</td>
<td style="border: 1px solid #dee2e6; padding: 12px;">Varia conforme o SGBD (APIs específicas)</td>
</tr>
<tr style="background: #f8f9fa;">
<td style="border: 1px solid #dee2e6; padding: 12px;">Escalabilidade</td>
<td style="border: 1px solid #dee2e6; padding: 12px;">Vertical (scaling up)</td>
<td style="border: 1px solid #dee2e6; padding: 12px;">Horizontal (scaling out)</td>
</tr>
<tr>
<td style="border: 1px solid #dee2e6; padding: 12px;">Consistência</td>
<td style="border: 1px solid #dee2e6; padding: 12px;">Forte (propriedades ACID)</td>
<td style="border: 1px solid #dee2e6; padding: 12px;">Geralmente eventual (modelo BASE), mas configurável</td>
</tr>
<tr style="background: #f8f9fa;">
<td style="border: 1px solid #dee2e6; padding: 12px;">Exemplos de Uso</td>
<td style="border: 1px solid #dee2e6; padding: 12px;">Sistemas transacionais, ERPs, e-commerce, finanças</td>
<td style="border: 1px solid #dee2e6; padding: 12px;">Big Data, IoT, redes sociais, gerenciamento de conteúdo, caching</td>
</tr>
</tbody>
</table>
</div>
<h2><a href="#cenários-de-uso-para-bancos-de-dados-sql" aria-hidden="true" class="anchor" id="cenários-de-uso-para-bancos-de-dados-sql"></a>Cenários de Uso para Bancos de Dados SQL</h2>
<p>Bancos de dados relacionais são a escolha ideal quando:</p>
<ul>
<li>A integridade dos dados e a consistência transacional (ACID) são requisitos não negociáveis.</li>
<li>Os dados são bem estruturados e seus requisitos de esquema são estáveis.</li>
<li>A aplicação necessita de consultas complexas que envolvem múltiplas tabelas (JOINs).</li>
</ul>
<p><strong>Exemplos:</strong> sistemas bancários, plataformas de e-commerce, sistemas de gestão empresarial (ERP), aplicações de contabilidade.</p>
<h2><a href="#cenários-de-uso-para-bancos-de-dados-nosql" aria-hidden="true" class="anchor" id="cenários-de-uso-para-bancos-de-dados-nosql"></a>Cenários de Uso para Bancos de Dados NoSQL</h2>
<p>Bancos de dados não relacionais são mais adequados quando:</p>
<ul>
<li>A aplicação precisa lidar com grandes volumes de dados com alta velocidade de escrita e leitura.</li>
<li>Os requisitos de dados são fluidos ou envolvem dados não estruturados ou semiestruturados.</li>
<li>A escalabilidade horizontal e a alta disponibilidade são mais críticas do que a consistência forte imediata.</li>
</ul>
<p><strong>Exemplos:</strong> redes sociais (grafos), catálogos de produtos com atributos variados (documentos), sistemas de caching de sessão (chave-valor), aplicações de Internet das Coisas (IoT) e análise de telemetria (colunares).</p>
<h2><a href="#conclusão" aria-hidden="true" class="anchor" id="conclusão"></a>Conclusão</h2>
<p>A decisão entre SQL e NoSQL não é uma escolha excludente. Ambas as tecnologias possuem méritos e são ferramentas poderosas quando aplicadas aos problemas corretos. A escolha deve ser orientada por uma análise criteriosa dos requisitos da aplicação, considerando o modelo de dados, as necessidades de escalabilidade, a performance esperada e as garantias de consistência.</p>
<p>Adicionalmente, a abordagem de persistência poliglota, onde múltiplos tipos de bancos de dados coexistem em uma mesma arquitetura para servir a diferentes funcionalidades, tem se tornado cada vez mais comum e eficaz.</p>
]]></content:encoded></item><item><title>Null, Undefined e Undeclared em Javascript</title><link>https://lg8609a.github.io/null-undefined-e-undeclared-em-javascript.html</link><description><![CDATA["Este artigo apresenta uma análise técnica de cada um desses conceitos, com exemplos práticos para clarificar suas definições, origens e implicações no desenvolvimento."]]></description><category>Javascript</category><category>Desenvolvimento Web</category><category>Boas Práticas</category><category>Tipos de Dados</category><guid>https://lg8609a.github.io/null-undefined-e-undeclared-em-javascript.html</guid><pubDate>Wed, 16 Jul 2025 00:00:00 GMT</pubDate><source url="https://lg8609a.github.io">tag-desenvolvimento-web</source><content:encoded><![CDATA[<h1><a href="#as-diferenças-essenciais-entre-null-undefined-e-undeclared-em-javascript" aria-hidden="true" class="anchor" id="as-diferenças-essenciais-entre-null-undefined-e-undeclared-em-javascript"></a>As Diferenças Essenciais entre Null, Undefined e Undeclared em JavaScript</h1>
<p>No ecossistema JavaScript, a representação da ausência de valor é um tópico que frequentemente causa confusão entre desenvolvedores, especialmente aqueles em início de carreira. Os termos &quot;null&quot;, &quot;undefined&quot; e o estado &quot;undeclared&quot; descrevem cenários distintos, e compreender suas diferenças é fundamental para a escrita de um código robusto, previsível e de fácil depuração.</p>
<h2><a href="#undefined-a-ausência-de-valor-padrão" aria-hidden="true" class="anchor" id="undefined-a-ausência-de-valor-padrão"></a>Undefined: A Ausência de Valor Padrão</h2>
<p>&quot;Undefined&quot; é um dos tipos primitivos de dados em JavaScript. Ele representa a ausência de um valor atribuído. O motor JavaScript (JavaScript engine) designa automaticamente o valor <em>undefined</em> em situações específicas, sem a intervenção do desenvolvedor.</p>
<p>Os cenários mais comuns onde &quot;undefined&quot; é encontrado são:</p>
<p><strong>Declaração sem inicialização:</strong> Uma variável declarada com &quot;let&quot;, &quot;const&quot; ou &quot;var&quot; que não teve um valor inicial atribuído.</p>
<div style="border: 1px solid #ccc; border-radius: 8px; padding: 16px; background: #f9f9f9; margin: 24px 0;">
<pre><code class="language-javascript">let nome;
console.log(nome); // Saída: undefined
</code></pre>
</div>
<p><strong>Funções sem retorno explícito:</strong> Uma função que não possui a instrução &quot;return&quot; ou que possui um &quot;return&quot; sem um valor especificado, retorna &quot;undefined&quot; por padrão.</p>
<div style="border: 1px solid #ccc; border-radius: 8px; padding: 16px; background: #f9f9f9; margin: 24px 0;">
<pre><code class="language-javascript">function calcular() {
  // Nenhuma instrução de retorno
}
console.log(calcular()); // Saída: undefined
</code></pre>
</div>
<p><strong>Parâmetros de função não fornecidos:</strong> Quando uma função é chamada sem os argumentos esperados.</p>
<div style="border: 1px solid #ccc; border-radius: 8px; padding: 16px; background: #f9f9f9; margin: 24px 0;">
<pre><code class="language-javascript">function saudar(nome) {
  console.log(`Olá, ${nome}`);
}
saudar(); // Saída: Olá, undefined
</code></pre>
</div>
<p><strong>Acesso a propriedades de objeto inexistentes:</strong> Ao tentar acessar uma propriedade que não foi definida em um objeto.</p>
<div style="border: 1px solid #ccc; border-radius: 8px; padding: 16px; background: #f9f9f9; margin: 24px 0;">
<pre><code class="language-javascript">const usuario = { id: 101 };
console.log(usuario.nome); // Saída: undefined
</code></pre>
</div>
<p>O operador &quot;typeof&quot; aplicado a uma variável que contém &quot;undefined&quot; retorna a string &quot;undefined&quot;.</p>
<h2><a href="#null-a-ausência-de-valor-intencional" aria-hidden="true" class="anchor" id="null-a-ausência-de-valor-intencional"></a>Null: A Ausência de Valor Intencional</h2>
<p>Assim como &quot;undefined&quot;, &quot;null&quot; também é um tipo primitivo que representa a ausência de valor. A diferença crucial reside na sua intencionalidade. O valor <em>null</em> é atribuído explicitamente por um desenvolvedor para indicar que uma variável não possui um valor ou que um objeto não existe.</p>
<p>Enquanto &quot;undefined&quot; é a ausência de valor por omissão, <em>null</em> é a ausência de valor por design. É comumente utilizado em cenários onde um objeto é esperado, mas não está disponível no momento.</p>
<div style="border: 1px solid #ccc; border-radius: 8px; padding: 16px; background: #f9f9f9; margin: 24px 0;">
<pre><code class="language-javascript">let dadosDoUsuario = null; // O valor é intencionalmente nulo

function buscarUsuario(id) {
  if (id === 1) {
    return { nome: 'João' };
  }
  // Retorna null para indicar que nenhum usuário foi encontrado
  return null;
}

dadosDoUsuario = buscarUsuario(2);
console.log(dadosDoUsuario); // Saída: null
</code></pre>
</div>
<p>Uma peculiaridade histórica do JavaScript é que o operador &quot;typeof&quot; para &quot;null&quot; retorna &quot;object&quot;. Este é um bug reconhecido nas primeiras versões da linguagem, mantido por razões de retrocompatibilidade.</p>
<h2><a href="#undeclared-a-ausência-de-declaração" aria-hidden="true" class="anchor" id="undeclared-a-ausência-de-declaração"></a>Undeclared: A Ausência de Declaração</h2>
<p>Diferente de &quot;null&quot; e &quot;undefined&quot;, o estado <em>undeclared</em> não é um valor em JavaScript, mas sim uma condição. Uma variável é considerada <em>undeclared</em> quando há uma tentativa de acessá-la sem que ela tenha sido declarada no escopo atual ou em escopos superiores.</p>
<p>A tentativa de utilizar um identificador não declarado resulta, na maioria dos casos, em um erro em tempo de execução do tipo &quot;ReferenceError&quot;, que interrompe a execução do script.</p>
<div style="border: 1px solid #ccc; border-radius: 8px; padding: 16px; background: #f9f9f9; margin: 24px 0;">
<pre><code class="language-javascript">console.log(variavelInexistente);
// Erro: Uncaught ReferenceError: variavelInexistente is not defined
</code></pre>
</div>
<p>Este erro é um mecanismo de segurança da linguagem que previne o uso de variáveis que não existem, evitando comportamentos inesperados.</p>
<h2><a href="#tabela-comparativa" aria-hidden="true" class="anchor" id="tabela-comparativa"></a>Tabela Comparativa</h2>
<p>Para consolidar as diferenças, a tabela abaixo resume as principais características de cada conceito.</p>
<table>
<thead>
<tr>
<th>Característica</th>
<th>undefined</th>
<th>null</th>
<th>undeclared</th>
</tr>
</thead>
<tbody>
<tr>
<td>Tipo (<code>typeof</code>)</td>
<td>&quot;undefined&quot;</td>
<td>&quot;object&quot; (quirk histórico)</td>
<td>Causa ReferenceError</td>
</tr>
<tr>
<td>Origem</td>
<td>Atribuído automaticamente pelo motor JS</td>
<td>Atribuído intencionalmente pelo desenvolvedor</td>
<td>Estado de um identificador não declarado</td>
</tr>
<tr>
<td>Representação</td>
<td>Uma variável que não teve valor atribuído</td>
<td>Ausência intencional de um valor (especialmente de um objeto)</td>
<td>Um identificador que não existe no escopo</td>
</tr>
<tr>
<td>Comparação <code>==</code></td>
<td>null == undefined resulta em true</td>
<td>null == undefined resulta em true</td>
<td>N/A (causa erro)</td>
</tr>
<tr>
<td>Comparação <code>===</code></td>
<td>null === undefined resulta em false</td>
<td>null === undefined resulta em false</td>
<td>N/A (causa erro)</td>
</tr>
</tbody>
</table>
<h2><a href="#implicações-práticas-e-boas-práticas" aria-hidden="true" class="anchor" id="implicações-práticas-e-boas-práticas"></a>Implicações Práticas e Boas Práticas</h2>
<ul>
<li><strong>Evite atribuições explícitas de &quot;undefined&quot;:</strong> Deixe que o motor JavaScript gerencie o estado &quot;undefined&quot;. Se for necessário indicar a ausência de um valor, &quot;null&quot; é a opção semanticamente correta.</li>
<li><strong>Utilize &quot;null&quot; para ausência intencional:</strong> Ao escrever funções que podem retornar um objeto, é uma prática comum retornar &quot;null&quot; para sinalizar que nenhum resultado foi encontrado.</li>
<li><strong>Prefira &quot;const&quot; e &quot;let&quot;:</strong> O uso de &quot;const&quot; e &quot;let&quot; em vez de &quot;var&quot; ajuda a evitar variáveis não declaradas, pois elas possuem escopo de bloco e geram erros se acessadas antes de sua declaração (Temporal Dead Zone).</li>
<li><strong>Use a comparação estrita (<code>===</code>):</strong> Para verificar a ausência de valor, utilize a comparação estrita para diferenciar &quot;null&quot; de &quot;undefined&quot;, evitando a coerção de tipo realizada pela comparação solta (<code>==</code>).</li>
</ul>
<h2><a href="#conclusão" aria-hidden="true" class="anchor" id="conclusão"></a>Conclusão</h2>
<p>Dominar a distinção entre &quot;undefined&quot;, &quot;null&quot; e &quot;undeclared&quot; é um passo importante para a proficiência em JavaScript. <em>Undefined</em> sinaliza um estado padrão de não inicialização; <em>Null</em> representa uma ausência de valor deliberada; e <em>Undeclared</em> indica um erro de programação onde um identificador não foi declarado. A aplicação correta desses conceitos resulta em um código mais claro, robusto e com menos probabilidade de erros inesperados.</p>
]]></content:encoded></item></channel></rss>